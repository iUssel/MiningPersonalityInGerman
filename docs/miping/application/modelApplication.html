<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>miping.application.modelApplication API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>miping.application.modelApplication</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import logging

from ..interfaces.twitter import TwitterAPI
from ..training.features import Features
from ..training.dataPreparation import DataPreparation
from ..models import OnnxModel, Profile, ModelBase

from tweepy import TweepError
from .predictionErrors import UserNameError, NotASuitableUserError
from ..training.features import NoGloveValueError


class ModelApplication:
    &#34;&#34;&#34;
    Central class for actually utilize trained models and
    do predictions. Wraps relevant function of other miping classes.
    Twitter API, models, and GloVe pipeline are saved to class
    variables to make the web application more efficient.
    Everything is initialized on the first request, afterwards
    all requests will be faster.
    &#34;&#34;&#34;

    # will hold twitter api object for class
    twitter = None
    &#34;&#34;&#34;Twitter API object&#34;&#34;&#34;
    # glove pipeline object for class
    glove_pipeline = None
    &#34;&#34;&#34;GloVe feature pipeline&#34;&#34;&#34;

    # useful for coverage statistics
    featuresObj = None
    &#34;&#34;&#34;Feature object instance for coverage statistics&#34;&#34;&#34;

    # trained and imported models
    big5_openness = None
    &#34;&#34;&#34;Imported model for Openness&#34;&#34;&#34;
    big5_conscientiousness = None
    &#34;&#34;&#34;Imported model for Conscientiousness&#34;&#34;&#34;
    big5_extraversion = None
    &#34;&#34;&#34;Imported model for Extraversion&#34;&#34;&#34;
    big5_agreeableness = None
    &#34;&#34;&#34;Imported model for Agreeableness&#34;&#34;&#34;
    big5_neuroticism = None
    &#34;&#34;&#34;Imported model for Neuroticism&#34;&#34;&#34;
    # big 5 list for loops
    big5List = [
        &#39;big5_openness&#39;,
        &#39;big5_conscientiousness&#39;,
        &#39;big5_extraversion&#39;,
        &#39;big5_agreeableness&#39;,
        &#39;big5_neuroticism&#39;,
    ]
    &#34;&#34;&#34;List of model variables for access in loop&#34;&#34;&#34;

    def __init__(
        self,
        twitter_consumer_key,
        twitter_consumer_secret,
        glove_file_path,
        dataBaseMode,
        modelPathDict,
        use_onnx_models=True,
    ):
        &#34;&#34;&#34;
        Initialize necessary APIs and import models.

        Twitter API is initialized, GloVe pipeline created and
        models imported.

        Parameters
        ----------
        twitter_consumer_key : string, default=None, required
            Developer API key for Twitter. Needed to query API.
        twitter_consumer_secret : string, default=None, required
            Developer API key secrect for Twitter. Needed to query API.
        glove_file_path : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=None, required
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file.
        modelPathDict : string, default=None, required
            ModelPathDict as returned from TrainedModels class.
            Contains the pathes to the trained models.
            E.g.:
            modelPathDict = {
                &#39;big5_openness&#39;: {
                    &#39;onnx&#39;: /miping/trainedModels/glovebig5_openness.ONNX,
                    &#39;pickle&#39;: /miping/trainedModels/glovebig5_openness.pickle
                },
                ...
            }
        use_onnx_models : string, default=True
            If True, use ONNX models. If False, use pickle models.
            Pickle models might provide more feature, but are a security risk.
        &#34;&#34;&#34;

        # initialize twitter api
        self.get_twitter(
            twitter_consumer_key,
            twitter_consumer_secret
        )

        # initialize glove_pipeline
        self.get_glove_pipeline(
            file_path=glove_file_path,
            dataBaseMode=dataBaseMode
        )

        # import models once
        self.importModels(
            modelPathDict=modelPathDict,
            use_onnx_models=use_onnx_models
        )

        return

    def importModels(
        self,
        modelPathDict,
        use_onnx_models,
    ):
        &#34;&#34;&#34;
        Import trained models once and save in class variables.

        Parameters
        ----------
        modelPathDict : string, default=None, required
            ModelPathDict as returned from TrainedModels class.
            Contains the pathes to the trained models.
            E.g.:
            modelPathDict = {
                &#39;big5_openness&#39;: {
                    &#39;onnx&#39;: /miping/trainedModels/glovebig5_openness.ONNX,
                    &#39;pickle&#39;: /miping/trainedModels/glovebig5_openness.pickle
                },
                ...
            }
        use_onnx_models : string, default=True
            If True, use ONNX models. If False, use pickle models.
            Pickle models might provide more feature, but are a security risk.
        &#34;&#34;&#34;
        for dimension in self.big5List:
            # check if already loaded
            if getattr(ModelApplication, dimension) is None:
                # import model
                model = None
                if use_onnx_models is True:
                    # path for saved trained models
                    filepath = modelPathDict[dimension][&#39;onnx&#39;]
                    # import onnx model
                    onnx = OnnxModel(
                        modelName=&#34;ONNX Model&#34;,
                        labelName=dimension,
                    )
                    onnx.importModelONNX(filepath)
                    model = onnx
                else:
                    # path for saved trained models
                    filepath = modelPathDict[dimension][&#39;pickle&#39;]
                    # import pickle model
                    # call import function for model
                    model = ModelBase.importModelPickle(filepath)
                    # get scikit model from imported pickle
                    model = model.model
                # assign loaded model to class variable
                setattr(ModelApplication, dimension, model)

        return

    def get_twitter(
        self,
        twitter_consumer_key,
        twitter_consumer_secret
    ):
        &#34;&#34;&#34;
        Initialize Twitter API, if not already happened, and return
        corresponding class variable.

        Parameters
        ----------
        twitter_consumer_key : string, default=None, required
            Developer API key for Twitter. Needed to query API.
        twitter_consumer_secret : string, default=None, required
            Developer API key secrect for Twitter. Needed to query API.

        Returns
        -------
        ModelApplication.twitter : TwitterAPI
            Initialized TwitterAPI object.
        &#34;&#34;&#34;
        if ModelApplication.twitter is None:
            # set Class attribute, not instance attribute
            # so API is only initialized once
            ModelApplication.twitter = TwitterAPI(
                consumer_key=twitter_consumer_key,
                consumer_secret=twitter_consumer_secret,
                wait_on_rate_limit_notify=True,
                removeNewLineChar=True,
                ignoreRetweets=True
            )
        return ModelApplication.twitter

    def validate_username_input(
        self,
        userName
    ):
        &#34;&#34;&#34;
        Check if passed userName is a valid Twitter userName.

        Exceptions are raised if the userName does not meet the
        requirements. This happens for saftey reasons, so nobody
        exploits the web application via buffer overflow or something
        else.

        Parameters
        ----------
        userName : string, default=None, required
            userName to validate.
        &#34;&#34;&#34;
        # check format
        minlength = 1
        maxlength = 30
        pattern = re.compile(&#39;^[A-Za-z0-9_]+$&#39;)

        # check length
        if len(userName) &lt; minlength or len(userName) &gt; maxlength:
            # length does not match twitter handle
            eString = &#39;Username length not valid&#39;
            raise UserNameError(eString)
        else:
            # valid length
            # check pattern
            match = pattern.match(userName)
            if match is None:
                # invalid
                eString = &#39;Username contains illegal characters&#39;
                raise UserNameError(eString)
            else:
                # string is valid
                return userName

        return

    def get_glove_pipeline(
        self,
        file_path,
        dataBaseMode,
    ):
        &#34;&#34;&#34;
        Initialize GloVe pipeline, if not already happened, and return
        corresponding class variable.

        Parameters
        ----------
        glove_file_path : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=None, required
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file..

        Returns
        -------
        ModelApplication.glove_pipeline : Pipeline
            Initialized GloVe pipeline.
        &#34;&#34;&#34;
        # if already created, skip init
        if ModelApplication.glove_pipeline is None:
            features = Features()
            pipeline = features.createGloVeFeaturePipeline(
                glovePath=file_path,
                dataBaseMode=dataBaseMode
            )
            # assign to class
            ModelApplication.glove_pipeline = pipeline
            ModelApplication.featuresObj = features

        return ModelApplication.glove_pipeline

    def create_profile(
        self,
        username,
    ):
        &#34;&#34;&#34;
        Get tweets for given username and create Profile object to return.

        It&#39;s checked if the user exists and is public. Then 200 tweets are
        loaded, combined into a single string, and the cleaning step
        is applied. The result is saved into a new Profile object.

        Parameters
        ----------
        username : string, default=None
            Already validated username to create profile for.

        Returns
        -------
        profile : Profile
            Miping Profile object filled based on the username.
        &#34;&#34;&#34;

        # get twitter api instance
        twitter = ModelApplication.twitter

        # get user id of user name
        try:
            userID = twitter.funcGetUserID(username)
        except TweepError:
            # multiple reasons for error
            # user not found, user suspended
            raise NotASuitableUserError(&#39;User not found or suspended.&#39;)

        # get tweets for given user
        try:
            tweetCol = twitter.funcGetTweetListByUser(
                    userID,
                    limit=200,
                    reRaiseExceptions=True
            )
        except TweepError:
            eString = &#34;Could not load user&#39;s tweets. User is maybe protected.&#34;
            raise NotASuitableUserError(eString)

        # total number of tweets
        totalTweets = len(tweetCol.tweetList)

        # check if there are any tweets
        # possible that a user only posts retweets
        if totalTweets == 0:
            raise NotASuitableUserError(&#39;User has no suitable tweets&#39;)

        # combine all tweets into one string
        textString = tweetCol.combine_tweet_text()
        # check if any words exist inside tweets
        if len(textString) == 0:
            raise NotASuitableUserError(&#34;No text inside user&#39;s tweets&#34;)
        # call data cleansing for combined string
        dataPre = DataPreparation()
        textString = dataPre.clean_text(
            textString=textString
        )
        if len(textString) == 0:
            eString = &#34;No text inside user&#39;s tweets after cleansing&#34;
            raise NotASuitableUserError(eString)

        # save string in profile
        profile = Profile(
            userID=userID,
            text=textString
        )

        return profile

    def get_personality(
        self,
        profileList,
    ):
        &#34;&#34;&#34;
        Return Big Five predictions for all profiles in profileList

        Features are calculated for whole profileList at once.
        An exception is raised if no matching GloVe vectors could
        be found. Do prediction with previously saved models
        for each dimension and save to returnDict.

        Parameters
        ----------
        profileList : list, default=None
            List of Profile objects for which predictions should
            be carried out.

        Returns
        -------
        returnDict : dict
            Dictionary containing Big Five, word coverage, and word
            count results.
        &#34;&#34;&#34;

        # feature pipeline
        pipeline = ModelApplication.glove_pipeline

        # calculate features
        try:
            features = pipeline.fit_transform(profileList)
        except NoGloveValueError:
            # this means, that the user&#39;s tweets
            # are not compatible with the used GloVe values
            # no words had a match -&gt; therefore user not suitable
            eString = &#34;User&#39;s tweets have no matching words.&#34;
            raise NotASuitableUserError(eString)

        # build return dict
        returnDict = {
            &#39;big5_openness&#39;: None,
            &#39;big5_conscientiousness&#39;: None,
            &#39;big5_extraversion&#39;: None,
            &#39;big5_agreeableness&#39;: None,
            &#39;big5_neuroticism&#39;: None,
            &#39;coverage&#39;: ModelApplication.featuresObj.coverageStatistics,
            &#39;wordCount&#39;: ModelApplication.featuresObj.wordCounts
        }

        # for every big5 dimension apply prediction
        for dimension in self.big5List:
            model = getattr(ModelApplication, dimension)
            # apply prediction
            big5result = model.predict(features)
            # save result in returnDict
            # contains predictions for all profiles
            returnDict[dimension] = big5result

        # instead of print, do log
        logging.log(level=logging.INFO, msg=&#34;Finished prediction&#34;)

        return returnDict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="miping.application.modelApplication.ModelApplication"><code class="flex name class">
<span>class <span class="ident">ModelApplication</span></span>
<span>(</span><span>twitter_consumer_key, twitter_consumer_secret, glove_file_path, dataBaseMode, modelPathDict, use_onnx_models=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Central class for actually utilize trained models and
do predictions. Wraps relevant function of other miping classes.
Twitter API, models, and GloVe pipeline are saved to class
variables to make the web application more efficient.
Everything is initialized on the first request, afterwards
all requests will be faster.</p>
<p>Initialize necessary APIs and import models.</p>
<p>Twitter API is initialized, GloVe pipeline created and
models imported.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>twitter_consumer_key</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Developer API key for Twitter. Needed to query API.</dd>
<dt><strong><code>twitter_consumer_secret</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Developer API key secrect for Twitter. Needed to query API.</dd>
<dt><strong><code>glove_file_path</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Full path to GloVe vector file (either database or
plain text file).</dd>
<dt><strong><code>dataBaseMode</code></strong> :&ensp;<code>boolean</code>, default=<code>None, required</code></dt>
<dd>If True, glove_file_path points to SQLite database file.
If False, flat vector file.</dd>
<dt><strong><code>modelPathDict</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>ModelPathDict as returned from TrainedModels class.
Contains the pathes to the trained models.
E.g.:
modelPathDict = {
'big5_openness': {
'onnx': /miping/trainedModels/glovebig5_openness.ONNX,
'pickle': /miping/trainedModels/glovebig5_openness.pickle
},
&hellip;
}</dd>
<dt><strong><code>use_onnx_models</code></strong> :&ensp;<code>string</code>, default=<code>True</code></dt>
<dd>If True, use ONNX models. If False, use pickle models.
Pickle models might provide more feature, but are a security risk.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelApplication:
    &#34;&#34;&#34;
    Central class for actually utilize trained models and
    do predictions. Wraps relevant function of other miping classes.
    Twitter API, models, and GloVe pipeline are saved to class
    variables to make the web application more efficient.
    Everything is initialized on the first request, afterwards
    all requests will be faster.
    &#34;&#34;&#34;

    # will hold twitter api object for class
    twitter = None
    &#34;&#34;&#34;Twitter API object&#34;&#34;&#34;
    # glove pipeline object for class
    glove_pipeline = None
    &#34;&#34;&#34;GloVe feature pipeline&#34;&#34;&#34;

    # useful for coverage statistics
    featuresObj = None
    &#34;&#34;&#34;Feature object instance for coverage statistics&#34;&#34;&#34;

    # trained and imported models
    big5_openness = None
    &#34;&#34;&#34;Imported model for Openness&#34;&#34;&#34;
    big5_conscientiousness = None
    &#34;&#34;&#34;Imported model for Conscientiousness&#34;&#34;&#34;
    big5_extraversion = None
    &#34;&#34;&#34;Imported model for Extraversion&#34;&#34;&#34;
    big5_agreeableness = None
    &#34;&#34;&#34;Imported model for Agreeableness&#34;&#34;&#34;
    big5_neuroticism = None
    &#34;&#34;&#34;Imported model for Neuroticism&#34;&#34;&#34;
    # big 5 list for loops
    big5List = [
        &#39;big5_openness&#39;,
        &#39;big5_conscientiousness&#39;,
        &#39;big5_extraversion&#39;,
        &#39;big5_agreeableness&#39;,
        &#39;big5_neuroticism&#39;,
    ]
    &#34;&#34;&#34;List of model variables for access in loop&#34;&#34;&#34;

    def __init__(
        self,
        twitter_consumer_key,
        twitter_consumer_secret,
        glove_file_path,
        dataBaseMode,
        modelPathDict,
        use_onnx_models=True,
    ):
        &#34;&#34;&#34;
        Initialize necessary APIs and import models.

        Twitter API is initialized, GloVe pipeline created and
        models imported.

        Parameters
        ----------
        twitter_consumer_key : string, default=None, required
            Developer API key for Twitter. Needed to query API.
        twitter_consumer_secret : string, default=None, required
            Developer API key secrect for Twitter. Needed to query API.
        glove_file_path : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=None, required
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file.
        modelPathDict : string, default=None, required
            ModelPathDict as returned from TrainedModels class.
            Contains the pathes to the trained models.
            E.g.:
            modelPathDict = {
                &#39;big5_openness&#39;: {
                    &#39;onnx&#39;: /miping/trainedModels/glovebig5_openness.ONNX,
                    &#39;pickle&#39;: /miping/trainedModels/glovebig5_openness.pickle
                },
                ...
            }
        use_onnx_models : string, default=True
            If True, use ONNX models. If False, use pickle models.
            Pickle models might provide more feature, but are a security risk.
        &#34;&#34;&#34;

        # initialize twitter api
        self.get_twitter(
            twitter_consumer_key,
            twitter_consumer_secret
        )

        # initialize glove_pipeline
        self.get_glove_pipeline(
            file_path=glove_file_path,
            dataBaseMode=dataBaseMode
        )

        # import models once
        self.importModels(
            modelPathDict=modelPathDict,
            use_onnx_models=use_onnx_models
        )

        return

    def importModels(
        self,
        modelPathDict,
        use_onnx_models,
    ):
        &#34;&#34;&#34;
        Import trained models once and save in class variables.

        Parameters
        ----------
        modelPathDict : string, default=None, required
            ModelPathDict as returned from TrainedModels class.
            Contains the pathes to the trained models.
            E.g.:
            modelPathDict = {
                &#39;big5_openness&#39;: {
                    &#39;onnx&#39;: /miping/trainedModels/glovebig5_openness.ONNX,
                    &#39;pickle&#39;: /miping/trainedModels/glovebig5_openness.pickle
                },
                ...
            }
        use_onnx_models : string, default=True
            If True, use ONNX models. If False, use pickle models.
            Pickle models might provide more feature, but are a security risk.
        &#34;&#34;&#34;
        for dimension in self.big5List:
            # check if already loaded
            if getattr(ModelApplication, dimension) is None:
                # import model
                model = None
                if use_onnx_models is True:
                    # path for saved trained models
                    filepath = modelPathDict[dimension][&#39;onnx&#39;]
                    # import onnx model
                    onnx = OnnxModel(
                        modelName=&#34;ONNX Model&#34;,
                        labelName=dimension,
                    )
                    onnx.importModelONNX(filepath)
                    model = onnx
                else:
                    # path for saved trained models
                    filepath = modelPathDict[dimension][&#39;pickle&#39;]
                    # import pickle model
                    # call import function for model
                    model = ModelBase.importModelPickle(filepath)
                    # get scikit model from imported pickle
                    model = model.model
                # assign loaded model to class variable
                setattr(ModelApplication, dimension, model)

        return

    def get_twitter(
        self,
        twitter_consumer_key,
        twitter_consumer_secret
    ):
        &#34;&#34;&#34;
        Initialize Twitter API, if not already happened, and return
        corresponding class variable.

        Parameters
        ----------
        twitter_consumer_key : string, default=None, required
            Developer API key for Twitter. Needed to query API.
        twitter_consumer_secret : string, default=None, required
            Developer API key secrect for Twitter. Needed to query API.

        Returns
        -------
        ModelApplication.twitter : TwitterAPI
            Initialized TwitterAPI object.
        &#34;&#34;&#34;
        if ModelApplication.twitter is None:
            # set Class attribute, not instance attribute
            # so API is only initialized once
            ModelApplication.twitter = TwitterAPI(
                consumer_key=twitter_consumer_key,
                consumer_secret=twitter_consumer_secret,
                wait_on_rate_limit_notify=True,
                removeNewLineChar=True,
                ignoreRetweets=True
            )
        return ModelApplication.twitter

    def validate_username_input(
        self,
        userName
    ):
        &#34;&#34;&#34;
        Check if passed userName is a valid Twitter userName.

        Exceptions are raised if the userName does not meet the
        requirements. This happens for saftey reasons, so nobody
        exploits the web application via buffer overflow or something
        else.

        Parameters
        ----------
        userName : string, default=None, required
            userName to validate.
        &#34;&#34;&#34;
        # check format
        minlength = 1
        maxlength = 30
        pattern = re.compile(&#39;^[A-Za-z0-9_]+$&#39;)

        # check length
        if len(userName) &lt; minlength or len(userName) &gt; maxlength:
            # length does not match twitter handle
            eString = &#39;Username length not valid&#39;
            raise UserNameError(eString)
        else:
            # valid length
            # check pattern
            match = pattern.match(userName)
            if match is None:
                # invalid
                eString = &#39;Username contains illegal characters&#39;
                raise UserNameError(eString)
            else:
                # string is valid
                return userName

        return

    def get_glove_pipeline(
        self,
        file_path,
        dataBaseMode,
    ):
        &#34;&#34;&#34;
        Initialize GloVe pipeline, if not already happened, and return
        corresponding class variable.

        Parameters
        ----------
        glove_file_path : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=None, required
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file..

        Returns
        -------
        ModelApplication.glove_pipeline : Pipeline
            Initialized GloVe pipeline.
        &#34;&#34;&#34;
        # if already created, skip init
        if ModelApplication.glove_pipeline is None:
            features = Features()
            pipeline = features.createGloVeFeaturePipeline(
                glovePath=file_path,
                dataBaseMode=dataBaseMode
            )
            # assign to class
            ModelApplication.glove_pipeline = pipeline
            ModelApplication.featuresObj = features

        return ModelApplication.glove_pipeline

    def create_profile(
        self,
        username,
    ):
        &#34;&#34;&#34;
        Get tweets for given username and create Profile object to return.

        It&#39;s checked if the user exists and is public. Then 200 tweets are
        loaded, combined into a single string, and the cleaning step
        is applied. The result is saved into a new Profile object.

        Parameters
        ----------
        username : string, default=None
            Already validated username to create profile for.

        Returns
        -------
        profile : Profile
            Miping Profile object filled based on the username.
        &#34;&#34;&#34;

        # get twitter api instance
        twitter = ModelApplication.twitter

        # get user id of user name
        try:
            userID = twitter.funcGetUserID(username)
        except TweepError:
            # multiple reasons for error
            # user not found, user suspended
            raise NotASuitableUserError(&#39;User not found or suspended.&#39;)

        # get tweets for given user
        try:
            tweetCol = twitter.funcGetTweetListByUser(
                    userID,
                    limit=200,
                    reRaiseExceptions=True
            )
        except TweepError:
            eString = &#34;Could not load user&#39;s tweets. User is maybe protected.&#34;
            raise NotASuitableUserError(eString)

        # total number of tweets
        totalTweets = len(tweetCol.tweetList)

        # check if there are any tweets
        # possible that a user only posts retweets
        if totalTweets == 0:
            raise NotASuitableUserError(&#39;User has no suitable tweets&#39;)

        # combine all tweets into one string
        textString = tweetCol.combine_tweet_text()
        # check if any words exist inside tweets
        if len(textString) == 0:
            raise NotASuitableUserError(&#34;No text inside user&#39;s tweets&#34;)
        # call data cleansing for combined string
        dataPre = DataPreparation()
        textString = dataPre.clean_text(
            textString=textString
        )
        if len(textString) == 0:
            eString = &#34;No text inside user&#39;s tweets after cleansing&#34;
            raise NotASuitableUserError(eString)

        # save string in profile
        profile = Profile(
            userID=userID,
            text=textString
        )

        return profile

    def get_personality(
        self,
        profileList,
    ):
        &#34;&#34;&#34;
        Return Big Five predictions for all profiles in profileList

        Features are calculated for whole profileList at once.
        An exception is raised if no matching GloVe vectors could
        be found. Do prediction with previously saved models
        for each dimension and save to returnDict.

        Parameters
        ----------
        profileList : list, default=None
            List of Profile objects for which predictions should
            be carried out.

        Returns
        -------
        returnDict : dict
            Dictionary containing Big Five, word coverage, and word
            count results.
        &#34;&#34;&#34;

        # feature pipeline
        pipeline = ModelApplication.glove_pipeline

        # calculate features
        try:
            features = pipeline.fit_transform(profileList)
        except NoGloveValueError:
            # this means, that the user&#39;s tweets
            # are not compatible with the used GloVe values
            # no words had a match -&gt; therefore user not suitable
            eString = &#34;User&#39;s tweets have no matching words.&#34;
            raise NotASuitableUserError(eString)

        # build return dict
        returnDict = {
            &#39;big5_openness&#39;: None,
            &#39;big5_conscientiousness&#39;: None,
            &#39;big5_extraversion&#39;: None,
            &#39;big5_agreeableness&#39;: None,
            &#39;big5_neuroticism&#39;: None,
            &#39;coverage&#39;: ModelApplication.featuresObj.coverageStatistics,
            &#39;wordCount&#39;: ModelApplication.featuresObj.wordCounts
        }

        # for every big5 dimension apply prediction
        for dimension in self.big5List:
            model = getattr(ModelApplication, dimension)
            # apply prediction
            big5result = model.predict(features)
            # save result in returnDict
            # contains predictions for all profiles
            returnDict[dimension] = big5result

        # instead of print, do log
        logging.log(level=logging.INFO, msg=&#34;Finished prediction&#34;)

        return returnDict</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="miping.application.modelApplication.ModelApplication.big5List"><code class="name">var <span class="ident">big5List</span></code></dt>
<dd>
<div class="desc"><p>List of model variables for access in loop</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.big5_agreeableness"><code class="name">var <span class="ident">big5_agreeableness</span></code></dt>
<dd>
<div class="desc"><p>Imported model for Agreeableness</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.big5_conscientiousness"><code class="name">var <span class="ident">big5_conscientiousness</span></code></dt>
<dd>
<div class="desc"><p>Imported model for Conscientiousness</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.big5_extraversion"><code class="name">var <span class="ident">big5_extraversion</span></code></dt>
<dd>
<div class="desc"><p>Imported model for Extraversion</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.big5_neuroticism"><code class="name">var <span class="ident">big5_neuroticism</span></code></dt>
<dd>
<div class="desc"><p>Imported model for Neuroticism</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.big5_openness"><code class="name">var <span class="ident">big5_openness</span></code></dt>
<dd>
<div class="desc"><p>Imported model for Openness</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.featuresObj"><code class="name">var <span class="ident">featuresObj</span></code></dt>
<dd>
<div class="desc"><p>Feature object instance for coverage statistics</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.glove_pipeline"><code class="name">var <span class="ident">glove_pipeline</span></code></dt>
<dd>
<div class="desc"><p>GloVe feature pipeline</p></div>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.twitter"><code class="name">var <span class="ident">twitter</span></code></dt>
<dd>
<div class="desc"><p>Twitter API object</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="miping.application.modelApplication.ModelApplication.create_profile"><code class="name flex">
<span>def <span class="ident">create_profile</span></span>(<span>self, username)</span>
</code></dt>
<dd>
<div class="desc"><p>Get tweets for given username and create Profile object to return.</p>
<p>It's checked if the user exists and is public. Then 200 tweets are
loaded, combined into a single string, and the cleaning step
is applied. The result is saved into a new Profile object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>string</code>, default=<code>None</code></dt>
<dd>Already validated username to create profile for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>profile</code></strong> :&ensp;<code>Profile</code></dt>
<dd>Miping Profile object filled based on the username.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_profile(
    self,
    username,
):
    &#34;&#34;&#34;
    Get tweets for given username and create Profile object to return.

    It&#39;s checked if the user exists and is public. Then 200 tweets are
    loaded, combined into a single string, and the cleaning step
    is applied. The result is saved into a new Profile object.

    Parameters
    ----------
    username : string, default=None
        Already validated username to create profile for.

    Returns
    -------
    profile : Profile
        Miping Profile object filled based on the username.
    &#34;&#34;&#34;

    # get twitter api instance
    twitter = ModelApplication.twitter

    # get user id of user name
    try:
        userID = twitter.funcGetUserID(username)
    except TweepError:
        # multiple reasons for error
        # user not found, user suspended
        raise NotASuitableUserError(&#39;User not found or suspended.&#39;)

    # get tweets for given user
    try:
        tweetCol = twitter.funcGetTweetListByUser(
                userID,
                limit=200,
                reRaiseExceptions=True
        )
    except TweepError:
        eString = &#34;Could not load user&#39;s tweets. User is maybe protected.&#34;
        raise NotASuitableUserError(eString)

    # total number of tweets
    totalTweets = len(tweetCol.tweetList)

    # check if there are any tweets
    # possible that a user only posts retweets
    if totalTweets == 0:
        raise NotASuitableUserError(&#39;User has no suitable tweets&#39;)

    # combine all tweets into one string
    textString = tweetCol.combine_tweet_text()
    # check if any words exist inside tweets
    if len(textString) == 0:
        raise NotASuitableUserError(&#34;No text inside user&#39;s tweets&#34;)
    # call data cleansing for combined string
    dataPre = DataPreparation()
    textString = dataPre.clean_text(
        textString=textString
    )
    if len(textString) == 0:
        eString = &#34;No text inside user&#39;s tweets after cleansing&#34;
        raise NotASuitableUserError(eString)

    # save string in profile
    profile = Profile(
        userID=userID,
        text=textString
    )

    return profile</code></pre>
</details>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.get_glove_pipeline"><code class="name flex">
<span>def <span class="ident">get_glove_pipeline</span></span>(<span>self, file_path, dataBaseMode)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize GloVe pipeline, if not already happened, and return
corresponding class variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>glove_file_path</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Full path to GloVe vector file (either database or
plain text file).</dd>
<dt><strong><code>dataBaseMode</code></strong> :&ensp;<code>boolean</code>, default=<code>None, required</code></dt>
<dd>If True, glove_file_path points to SQLite database file.
If False, flat vector file..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelApplication.glove_pipeline : Pipeline</code></dt>
<dd>Initialized GloVe pipeline.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_glove_pipeline(
    self,
    file_path,
    dataBaseMode,
):
    &#34;&#34;&#34;
    Initialize GloVe pipeline, if not already happened, and return
    corresponding class variable.

    Parameters
    ----------
    glove_file_path : string, default=None, required
        Full path to GloVe vector file (either database or
        plain text file).
    dataBaseMode : boolean, default=None, required
        If True, glove_file_path points to SQLite database file.
        If False, flat vector file..

    Returns
    -------
    ModelApplication.glove_pipeline : Pipeline
        Initialized GloVe pipeline.
    &#34;&#34;&#34;
    # if already created, skip init
    if ModelApplication.glove_pipeline is None:
        features = Features()
        pipeline = features.createGloVeFeaturePipeline(
            glovePath=file_path,
            dataBaseMode=dataBaseMode
        )
        # assign to class
        ModelApplication.glove_pipeline = pipeline
        ModelApplication.featuresObj = features

    return ModelApplication.glove_pipeline</code></pre>
</details>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.get_personality"><code class="name flex">
<span>def <span class="ident">get_personality</span></span>(<span>self, profileList)</span>
</code></dt>
<dd>
<div class="desc"><p>Return Big Five predictions for all profiles in profileList</p>
<p>Features are calculated for whole profileList at once.
An exception is raised if no matching GloVe vectors could
be found. Do prediction with previously saved models
for each dimension and save to returnDict.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>profileList</code></strong> :&ensp;<code>list</code>, default=<code>None</code></dt>
<dd>List of Profile objects for which predictions should
be carried out.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>returnDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing Big Five, word coverage, and word
count results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_personality(
    self,
    profileList,
):
    &#34;&#34;&#34;
    Return Big Five predictions for all profiles in profileList

    Features are calculated for whole profileList at once.
    An exception is raised if no matching GloVe vectors could
    be found. Do prediction with previously saved models
    for each dimension and save to returnDict.

    Parameters
    ----------
    profileList : list, default=None
        List of Profile objects for which predictions should
        be carried out.

    Returns
    -------
    returnDict : dict
        Dictionary containing Big Five, word coverage, and word
        count results.
    &#34;&#34;&#34;

    # feature pipeline
    pipeline = ModelApplication.glove_pipeline

    # calculate features
    try:
        features = pipeline.fit_transform(profileList)
    except NoGloveValueError:
        # this means, that the user&#39;s tweets
        # are not compatible with the used GloVe values
        # no words had a match -&gt; therefore user not suitable
        eString = &#34;User&#39;s tweets have no matching words.&#34;
        raise NotASuitableUserError(eString)

    # build return dict
    returnDict = {
        &#39;big5_openness&#39;: None,
        &#39;big5_conscientiousness&#39;: None,
        &#39;big5_extraversion&#39;: None,
        &#39;big5_agreeableness&#39;: None,
        &#39;big5_neuroticism&#39;: None,
        &#39;coverage&#39;: ModelApplication.featuresObj.coverageStatistics,
        &#39;wordCount&#39;: ModelApplication.featuresObj.wordCounts
    }

    # for every big5 dimension apply prediction
    for dimension in self.big5List:
        model = getattr(ModelApplication, dimension)
        # apply prediction
        big5result = model.predict(features)
        # save result in returnDict
        # contains predictions for all profiles
        returnDict[dimension] = big5result

    # instead of print, do log
    logging.log(level=logging.INFO, msg=&#34;Finished prediction&#34;)

    return returnDict</code></pre>
</details>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.get_twitter"><code class="name flex">
<span>def <span class="ident">get_twitter</span></span>(<span>self, twitter_consumer_key, twitter_consumer_secret)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Twitter API, if not already happened, and return
corresponding class variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>twitter_consumer_key</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Developer API key for Twitter. Needed to query API.</dd>
<dt><strong><code>twitter_consumer_secret</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Developer API key secrect for Twitter. Needed to query API.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelApplication.twitter : TwitterAPI</code></dt>
<dd>Initialized TwitterAPI object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_twitter(
    self,
    twitter_consumer_key,
    twitter_consumer_secret
):
    &#34;&#34;&#34;
    Initialize Twitter API, if not already happened, and return
    corresponding class variable.

    Parameters
    ----------
    twitter_consumer_key : string, default=None, required
        Developer API key for Twitter. Needed to query API.
    twitter_consumer_secret : string, default=None, required
        Developer API key secrect for Twitter. Needed to query API.

    Returns
    -------
    ModelApplication.twitter : TwitterAPI
        Initialized TwitterAPI object.
    &#34;&#34;&#34;
    if ModelApplication.twitter is None:
        # set Class attribute, not instance attribute
        # so API is only initialized once
        ModelApplication.twitter = TwitterAPI(
            consumer_key=twitter_consumer_key,
            consumer_secret=twitter_consumer_secret,
            wait_on_rate_limit_notify=True,
            removeNewLineChar=True,
            ignoreRetweets=True
        )
    return ModelApplication.twitter</code></pre>
</details>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.importModels"><code class="name flex">
<span>def <span class="ident">importModels</span></span>(<span>self, modelPathDict, use_onnx_models)</span>
</code></dt>
<dd>
<div class="desc"><p>Import trained models once and save in class variables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modelPathDict</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>ModelPathDict as returned from TrainedModels class.
Contains the pathes to the trained models.
E.g.:
modelPathDict = {
'big5_openness': {
'onnx': /miping/trainedModels/glovebig5_openness.ONNX,
'pickle': /miping/trainedModels/glovebig5_openness.pickle
},
&hellip;
}</dd>
<dt><strong><code>use_onnx_models</code></strong> :&ensp;<code>string</code>, default=<code>True</code></dt>
<dd>If True, use ONNX models. If False, use pickle models.
Pickle models might provide more feature, but are a security risk.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importModels(
    self,
    modelPathDict,
    use_onnx_models,
):
    &#34;&#34;&#34;
    Import trained models once and save in class variables.

    Parameters
    ----------
    modelPathDict : string, default=None, required
        ModelPathDict as returned from TrainedModels class.
        Contains the pathes to the trained models.
        E.g.:
        modelPathDict = {
            &#39;big5_openness&#39;: {
                &#39;onnx&#39;: /miping/trainedModels/glovebig5_openness.ONNX,
                &#39;pickle&#39;: /miping/trainedModels/glovebig5_openness.pickle
            },
            ...
        }
    use_onnx_models : string, default=True
        If True, use ONNX models. If False, use pickle models.
        Pickle models might provide more feature, but are a security risk.
    &#34;&#34;&#34;
    for dimension in self.big5List:
        # check if already loaded
        if getattr(ModelApplication, dimension) is None:
            # import model
            model = None
            if use_onnx_models is True:
                # path for saved trained models
                filepath = modelPathDict[dimension][&#39;onnx&#39;]
                # import onnx model
                onnx = OnnxModel(
                    modelName=&#34;ONNX Model&#34;,
                    labelName=dimension,
                )
                onnx.importModelONNX(filepath)
                model = onnx
            else:
                # path for saved trained models
                filepath = modelPathDict[dimension][&#39;pickle&#39;]
                # import pickle model
                # call import function for model
                model = ModelBase.importModelPickle(filepath)
                # get scikit model from imported pickle
                model = model.model
            # assign loaded model to class variable
            setattr(ModelApplication, dimension, model)

    return</code></pre>
</details>
</dd>
<dt id="miping.application.modelApplication.ModelApplication.validate_username_input"><code class="name flex">
<span>def <span class="ident">validate_username_input</span></span>(<span>self, userName)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if passed userName is a valid Twitter userName.</p>
<p>Exceptions are raised if the userName does not meet the
requirements. This happens for saftey reasons, so nobody
exploits the web application via buffer overflow or something
else.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userName</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>userName to validate.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_username_input(
    self,
    userName
):
    &#34;&#34;&#34;
    Check if passed userName is a valid Twitter userName.

    Exceptions are raised if the userName does not meet the
    requirements. This happens for saftey reasons, so nobody
    exploits the web application via buffer overflow or something
    else.

    Parameters
    ----------
    userName : string, default=None, required
        userName to validate.
    &#34;&#34;&#34;
    # check format
    minlength = 1
    maxlength = 30
    pattern = re.compile(&#39;^[A-Za-z0-9_]+$&#39;)

    # check length
    if len(userName) &lt; minlength or len(userName) &gt; maxlength:
        # length does not match twitter handle
        eString = &#39;Username length not valid&#39;
        raise UserNameError(eString)
    else:
        # valid length
        # check pattern
        match = pattern.match(userName)
        if match is None:
            # invalid
            eString = &#39;Username contains illegal characters&#39;
            raise UserNameError(eString)
        else:
            # string is valid
            return userName

    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="miping.application" href="index.html">miping.application</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="miping.application.modelApplication.ModelApplication" href="#miping.application.modelApplication.ModelApplication">ModelApplication</a></code></h4>
<ul class="">
<li><code><a title="miping.application.modelApplication.ModelApplication.big5List" href="#miping.application.modelApplication.ModelApplication.big5List">big5List</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.big5_agreeableness" href="#miping.application.modelApplication.ModelApplication.big5_agreeableness">big5_agreeableness</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.big5_conscientiousness" href="#miping.application.modelApplication.ModelApplication.big5_conscientiousness">big5_conscientiousness</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.big5_extraversion" href="#miping.application.modelApplication.ModelApplication.big5_extraversion">big5_extraversion</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.big5_neuroticism" href="#miping.application.modelApplication.ModelApplication.big5_neuroticism">big5_neuroticism</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.big5_openness" href="#miping.application.modelApplication.ModelApplication.big5_openness">big5_openness</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.create_profile" href="#miping.application.modelApplication.ModelApplication.create_profile">create_profile</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.featuresObj" href="#miping.application.modelApplication.ModelApplication.featuresObj">featuresObj</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.get_glove_pipeline" href="#miping.application.modelApplication.ModelApplication.get_glove_pipeline">get_glove_pipeline</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.get_personality" href="#miping.application.modelApplication.ModelApplication.get_personality">get_personality</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.get_twitter" href="#miping.application.modelApplication.ModelApplication.get_twitter">get_twitter</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.glove_pipeline" href="#miping.application.modelApplication.ModelApplication.glove_pipeline">glove_pipeline</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.importModels" href="#miping.application.modelApplication.ModelApplication.importModels">importModels</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.twitter" href="#miping.application.modelApplication.ModelApplication.twitter">twitter</a></code></li>
<li><code><a title="miping.application.modelApplication.ModelApplication.validate_username_input" href="#miping.application.modelApplication.ModelApplication.validate_username_input">validate_username_input</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>