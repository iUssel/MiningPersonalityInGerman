<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>miping.interfaces.glove API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>miping.interfaces.glove</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sqlite3
import pandas
from os import path
# this line logs an error, because the module contains a C libray
# which is not inspected, but the code works as it is
from sqlite3 import Error


class GloVe:
    &#34;&#34;&#34;
    GloVe API class encloses communication related to GloVe data.
    Either GloVe SQLite database or direct flat file.
    &#34;&#34;&#34;

    def __init__(
        self,
        filePath,
        dataBaseMode=True,
    ):
        &#34;&#34;&#34;
        Initialization of GloVe to establish DB connection
        or load flat file into memory. DB connection is more
        memory efficient.

        Parameters
        ----------
        filePath : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=True
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file.
        &#34;&#34;&#34;
        # save in instance
        self.dataBaseMode = dataBaseMode

        if path.exists(filePath) is False:
            # file does not exist
            eString = &#34;Did not find GloVe file passed in GloVe class&#34;
            raise Exception(eString)

        if dataBaseMode is True:
            print(&#34;Using GloVe database&#34;)
            self.connection = self._create_connection(
                # sql lite needs string as path
                db_file=str(filePath)
            )
        else:
            print(&#34;Using GloVe file&#34;)
            # load pre trained GloVe word embedding
            glove_df = self.loadGloVeFile(
                glovePath=filePath
            )

            self.glove_df = glove_df

        return

    def getGloVeByWordList(
        self,
        wordList
    ):
        &#34;&#34;&#34;
        For each word in wordList get the corresponding GloVe vector.

        If none exists just ignore the word. Since SQLite database
        is limited in query length, the query is split into 999er chunks.
        If flat file is use, the approach is more simple.
        The returned DataFrame includes duplicates, to represent the
        input list as close as possible (for personality prediciton this
        is usually the preferred approach, because it caputes word
        reptitions).

        Parameters
        ----------
        wordList : list, default=None, required
            List of words to get GloVe vector values for.

        Returns
        -------
        glove_val_df : DataFrame
            Pandas Dataframe containing the glove vector values for
            the given word list.
        &#34;&#34;&#34;

        if self.dataBaseMode is True:
            # since sqlite is limited in its query length
            # 999 chunks
            apiChunks = 999
            chunks = [
                wordList[
                    x:x+apiChunks
                ] for x in range(0, len(wordList), apiChunks)
            ]
            chunkCollectionDF = pandas.DataFrame()
            # for each 999er chunk, we will perform an SQL request
            for chunkList in chunks:
                # compose sql with length of chunk of word list
                # so that question marks ? can be added
                sql = &#34;SELECT * FROM glove WHERE words IN ({seq})&#34;.format(
                        seq=&#39;,&#39;.join([&#39;?&#39;]*len(chunkList))
                    )
                # query database and get data frame with unique values
                unique_glove_df = pandas.read_sql_query(
                    con=self.connection,
                    sql=sql,
                    params=chunkList,
                    index_col=&#39;words&#39;
                )
                # add to data frame
                chunkCollectionDF = chunkCollectionDF.append(unique_glove_df)
            # make returned rows unique
            # due to chunks some duplicates are possible
            completeUniqueDF = chunkCollectionDF.drop_duplicates()
            # since returned values are unique we have to get the intersection
            # including duplicates now
            glove_val_df = (
                completeUniqueDF.loc[
                    completeUniqueDF.index.intersection(wordList)
                ]
            )
        else:
            # get values from loaded glove
            glove_val_df = (
                self.glove_df.loc[self.glove_df.index.intersection(wordList)]
            )

        return glove_val_df

    def get_index_list(
        self,
    ):
        &#34;&#34;&#34;
        Return words existing in GloVe.

        This helps to make more efficient queries, by sorting out
        words that do not have a vector value before getting
        the actual values.

        Returns
        -------
        index_list : list
            List containing only the words existing in GloVe.
        &#34;&#34;&#34;

        # depending on data if data base mode or not
        if self.dataBaseMode is True:
            # get index as list from data base
            sql = &#34;SELECT words FROM glove;&#34;
            dataFrame = pandas.read_sql_query(
                con=self.connection,
                sql=sql,
                index_col=&#39;words&#39;
            )
            # convert to list
            index_list = list(dataFrame.index)
        else:
            # get index from fully loaded glove
            index_list = list(self.glove_df.index)

        return index_list

    def _create_connection(
        self,
        db_file
    ):
        &#34;&#34;&#34;
        Initialize database connection based on file path.

        Parameters
        ----------
        db_file : string, default=None, required
            File path to SQLite database file.

        Returns
        -------
        conn : sqlite3 connection
            Initialized connection ready for queries.
        &#34;&#34;&#34;
        conn = None
        try:
            conn = sqlite3.connect(db_file)
            conn.row_factory = sqlite3.Row
            return conn
        except Error as e:
            print(e)

        return conn

    def loadGloVeFile(
        self,
        glovePath
    ):
        &#34;&#34;&#34;
        Load GloVe from flat file and return DataFrame.

        Parameters
        ----------
        glovePath : string, default=None, required
            Full path to glove flat vector file.

        Returns
        -------
        glove_df : DataFrame
            Pandas DataFrame containing all words and vectors.
        &#34;&#34;&#34;

        print(&#34;\nLoading GloVe&#34;)

        # file exists, so we load it
        glove_df = pandas.read_csv(
            filepath_or_buffer=glovePath,
            sep=&#34; &#34;,
            header=None,
            encoding=&#39;utf_8&#39;,
        )
        # set words as index
        glove_df.set_index(0, inplace=True)
        glove_df.rename_axis(&#34;words&#34;, axis=&#34;index&#34;, inplace=True)

        print(
            &#34;GloVe loaded with &#34; +
            str(len(glove_df)) +
            &#34; as count of words.&#34;
        )

        return glove_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="miping.interfaces.glove.GloVe"><code class="flex name class">
<span>class <span class="ident">GloVe</span></span>
<span>(</span><span>filePath, dataBaseMode=True)</span>
</code></dt>
<dd>
<div class="desc"><p>GloVe API class encloses communication related to GloVe data.
Either GloVe SQLite database or direct flat file.</p>
<p>Initialization of GloVe to establish DB connection
or load flat file into memory. DB connection is more
memory efficient.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filePath</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Full path to GloVe vector file (either database or
plain text file).</dd>
<dt><strong><code>dataBaseMode</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If True, glove_file_path points to SQLite database file.
If False, flat vector file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GloVe:
    &#34;&#34;&#34;
    GloVe API class encloses communication related to GloVe data.
    Either GloVe SQLite database or direct flat file.
    &#34;&#34;&#34;

    def __init__(
        self,
        filePath,
        dataBaseMode=True,
    ):
        &#34;&#34;&#34;
        Initialization of GloVe to establish DB connection
        or load flat file into memory. DB connection is more
        memory efficient.

        Parameters
        ----------
        filePath : string, default=None, required
            Full path to GloVe vector file (either database or
            plain text file).
        dataBaseMode : boolean, default=True
            If True, glove_file_path points to SQLite database file.
            If False, flat vector file.
        &#34;&#34;&#34;
        # save in instance
        self.dataBaseMode = dataBaseMode

        if path.exists(filePath) is False:
            # file does not exist
            eString = &#34;Did not find GloVe file passed in GloVe class&#34;
            raise Exception(eString)

        if dataBaseMode is True:
            print(&#34;Using GloVe database&#34;)
            self.connection = self._create_connection(
                # sql lite needs string as path
                db_file=str(filePath)
            )
        else:
            print(&#34;Using GloVe file&#34;)
            # load pre trained GloVe word embedding
            glove_df = self.loadGloVeFile(
                glovePath=filePath
            )

            self.glove_df = glove_df

        return

    def getGloVeByWordList(
        self,
        wordList
    ):
        &#34;&#34;&#34;
        For each word in wordList get the corresponding GloVe vector.

        If none exists just ignore the word. Since SQLite database
        is limited in query length, the query is split into 999er chunks.
        If flat file is use, the approach is more simple.
        The returned DataFrame includes duplicates, to represent the
        input list as close as possible (for personality prediciton this
        is usually the preferred approach, because it caputes word
        reptitions).

        Parameters
        ----------
        wordList : list, default=None, required
            List of words to get GloVe vector values for.

        Returns
        -------
        glove_val_df : DataFrame
            Pandas Dataframe containing the glove vector values for
            the given word list.
        &#34;&#34;&#34;

        if self.dataBaseMode is True:
            # since sqlite is limited in its query length
            # 999 chunks
            apiChunks = 999
            chunks = [
                wordList[
                    x:x+apiChunks
                ] for x in range(0, len(wordList), apiChunks)
            ]
            chunkCollectionDF = pandas.DataFrame()
            # for each 999er chunk, we will perform an SQL request
            for chunkList in chunks:
                # compose sql with length of chunk of word list
                # so that question marks ? can be added
                sql = &#34;SELECT * FROM glove WHERE words IN ({seq})&#34;.format(
                        seq=&#39;,&#39;.join([&#39;?&#39;]*len(chunkList))
                    )
                # query database and get data frame with unique values
                unique_glove_df = pandas.read_sql_query(
                    con=self.connection,
                    sql=sql,
                    params=chunkList,
                    index_col=&#39;words&#39;
                )
                # add to data frame
                chunkCollectionDF = chunkCollectionDF.append(unique_glove_df)
            # make returned rows unique
            # due to chunks some duplicates are possible
            completeUniqueDF = chunkCollectionDF.drop_duplicates()
            # since returned values are unique we have to get the intersection
            # including duplicates now
            glove_val_df = (
                completeUniqueDF.loc[
                    completeUniqueDF.index.intersection(wordList)
                ]
            )
        else:
            # get values from loaded glove
            glove_val_df = (
                self.glove_df.loc[self.glove_df.index.intersection(wordList)]
            )

        return glove_val_df

    def get_index_list(
        self,
    ):
        &#34;&#34;&#34;
        Return words existing in GloVe.

        This helps to make more efficient queries, by sorting out
        words that do not have a vector value before getting
        the actual values.

        Returns
        -------
        index_list : list
            List containing only the words existing in GloVe.
        &#34;&#34;&#34;

        # depending on data if data base mode or not
        if self.dataBaseMode is True:
            # get index as list from data base
            sql = &#34;SELECT words FROM glove;&#34;
            dataFrame = pandas.read_sql_query(
                con=self.connection,
                sql=sql,
                index_col=&#39;words&#39;
            )
            # convert to list
            index_list = list(dataFrame.index)
        else:
            # get index from fully loaded glove
            index_list = list(self.glove_df.index)

        return index_list

    def _create_connection(
        self,
        db_file
    ):
        &#34;&#34;&#34;
        Initialize database connection based on file path.

        Parameters
        ----------
        db_file : string, default=None, required
            File path to SQLite database file.

        Returns
        -------
        conn : sqlite3 connection
            Initialized connection ready for queries.
        &#34;&#34;&#34;
        conn = None
        try:
            conn = sqlite3.connect(db_file)
            conn.row_factory = sqlite3.Row
            return conn
        except Error as e:
            print(e)

        return conn

    def loadGloVeFile(
        self,
        glovePath
    ):
        &#34;&#34;&#34;
        Load GloVe from flat file and return DataFrame.

        Parameters
        ----------
        glovePath : string, default=None, required
            Full path to glove flat vector file.

        Returns
        -------
        glove_df : DataFrame
            Pandas DataFrame containing all words and vectors.
        &#34;&#34;&#34;

        print(&#34;\nLoading GloVe&#34;)

        # file exists, so we load it
        glove_df = pandas.read_csv(
            filepath_or_buffer=glovePath,
            sep=&#34; &#34;,
            header=None,
            encoding=&#39;utf_8&#39;,
        )
        # set words as index
        glove_df.set_index(0, inplace=True)
        glove_df.rename_axis(&#34;words&#34;, axis=&#34;index&#34;, inplace=True)

        print(
            &#34;GloVe loaded with &#34; +
            str(len(glove_df)) +
            &#34; as count of words.&#34;
        )

        return glove_df</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="miping.interfaces.glove.GloVe.getGloVeByWordList"><code class="name flex">
<span>def <span class="ident">getGloVeByWordList</span></span>(<span>self, wordList)</span>
</code></dt>
<dd>
<div class="desc"><p>For each word in wordList get the corresponding GloVe vector.</p>
<p>If none exists just ignore the word. Since SQLite database
is limited in query length, the query is split into 999er chunks.
If flat file is use, the approach is more simple.
The returned DataFrame includes duplicates, to represent the
input list as close as possible (for personality prediciton this
is usually the preferred approach, because it caputes word
reptitions).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wordList</code></strong> :&ensp;<code>list</code>, default=<code>None, required</code></dt>
<dd>List of words to get GloVe vector values for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>glove_val_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Pandas Dataframe containing the glove vector values for
the given word list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGloVeByWordList(
    self,
    wordList
):
    &#34;&#34;&#34;
    For each word in wordList get the corresponding GloVe vector.

    If none exists just ignore the word. Since SQLite database
    is limited in query length, the query is split into 999er chunks.
    If flat file is use, the approach is more simple.
    The returned DataFrame includes duplicates, to represent the
    input list as close as possible (for personality prediciton this
    is usually the preferred approach, because it caputes word
    reptitions).

    Parameters
    ----------
    wordList : list, default=None, required
        List of words to get GloVe vector values for.

    Returns
    -------
    glove_val_df : DataFrame
        Pandas Dataframe containing the glove vector values for
        the given word list.
    &#34;&#34;&#34;

    if self.dataBaseMode is True:
        # since sqlite is limited in its query length
        # 999 chunks
        apiChunks = 999
        chunks = [
            wordList[
                x:x+apiChunks
            ] for x in range(0, len(wordList), apiChunks)
        ]
        chunkCollectionDF = pandas.DataFrame()
        # for each 999er chunk, we will perform an SQL request
        for chunkList in chunks:
            # compose sql with length of chunk of word list
            # so that question marks ? can be added
            sql = &#34;SELECT * FROM glove WHERE words IN ({seq})&#34;.format(
                    seq=&#39;,&#39;.join([&#39;?&#39;]*len(chunkList))
                )
            # query database and get data frame with unique values
            unique_glove_df = pandas.read_sql_query(
                con=self.connection,
                sql=sql,
                params=chunkList,
                index_col=&#39;words&#39;
            )
            # add to data frame
            chunkCollectionDF = chunkCollectionDF.append(unique_glove_df)
        # make returned rows unique
        # due to chunks some duplicates are possible
        completeUniqueDF = chunkCollectionDF.drop_duplicates()
        # since returned values are unique we have to get the intersection
        # including duplicates now
        glove_val_df = (
            completeUniqueDF.loc[
                completeUniqueDF.index.intersection(wordList)
            ]
        )
    else:
        # get values from loaded glove
        glove_val_df = (
            self.glove_df.loc[self.glove_df.index.intersection(wordList)]
        )

    return glove_val_df</code></pre>
</details>
</dd>
<dt id="miping.interfaces.glove.GloVe.get_index_list"><code class="name flex">
<span>def <span class="ident">get_index_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return words existing in GloVe.</p>
<p>This helps to make more efficient queries, by sorting out
words that do not have a vector value before getting
the actual values.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List containing only the words existing in GloVe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_list(
    self,
):
    &#34;&#34;&#34;
    Return words existing in GloVe.

    This helps to make more efficient queries, by sorting out
    words that do not have a vector value before getting
    the actual values.

    Returns
    -------
    index_list : list
        List containing only the words existing in GloVe.
    &#34;&#34;&#34;

    # depending on data if data base mode or not
    if self.dataBaseMode is True:
        # get index as list from data base
        sql = &#34;SELECT words FROM glove;&#34;
        dataFrame = pandas.read_sql_query(
            con=self.connection,
            sql=sql,
            index_col=&#39;words&#39;
        )
        # convert to list
        index_list = list(dataFrame.index)
    else:
        # get index from fully loaded glove
        index_list = list(self.glove_df.index)

    return index_list</code></pre>
</details>
</dd>
<dt id="miping.interfaces.glove.GloVe.loadGloVeFile"><code class="name flex">
<span>def <span class="ident">loadGloVeFile</span></span>(<span>self, glovePath)</span>
</code></dt>
<dd>
<div class="desc"><p>Load GloVe from flat file and return DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>glovePath</code></strong> :&ensp;<code>string</code>, default=<code>None, required</code></dt>
<dd>Full path to glove flat vector file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>glove_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Pandas DataFrame containing all words and vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadGloVeFile(
    self,
    glovePath
):
    &#34;&#34;&#34;
    Load GloVe from flat file and return DataFrame.

    Parameters
    ----------
    glovePath : string, default=None, required
        Full path to glove flat vector file.

    Returns
    -------
    glove_df : DataFrame
        Pandas DataFrame containing all words and vectors.
    &#34;&#34;&#34;

    print(&#34;\nLoading GloVe&#34;)

    # file exists, so we load it
    glove_df = pandas.read_csv(
        filepath_or_buffer=glovePath,
        sep=&#34; &#34;,
        header=None,
        encoding=&#39;utf_8&#39;,
    )
    # set words as index
    glove_df.set_index(0, inplace=True)
    glove_df.rename_axis(&#34;words&#34;, axis=&#34;index&#34;, inplace=True)

    print(
        &#34;GloVe loaded with &#34; +
        str(len(glove_df)) +
        &#34; as count of words.&#34;
    )

    return glove_df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="miping.interfaces" href="index.html">miping.interfaces</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="miping.interfaces.glove.GloVe" href="#miping.interfaces.glove.GloVe">GloVe</a></code></h4>
<ul class="">
<li><code><a title="miping.interfaces.glove.GloVe.getGloVeByWordList" href="#miping.interfaces.glove.GloVe.getGloVeByWordList">getGloVeByWordList</a></code></li>
<li><code><a title="miping.interfaces.glove.GloVe.get_index_list" href="#miping.interfaces.glove.GloVe.get_index_list">get_index_list</a></code></li>
<li><code><a title="miping.interfaces.glove.GloVe.loadGloVeFile" href="#miping.interfaces.glove.GloVe.loadGloVeFile">loadGloVeFile</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>